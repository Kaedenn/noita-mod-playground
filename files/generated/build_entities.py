#!/usr/bin/env python3

"""
Create the entities.lua file
"""

import argparse
import collections
import io
import logging
import os
import sys

import lxml.etree as et

logging.basicConfig(format="%(module)s:%(lineno)s: %(levelname)s: %(message)s",
                    level=logging.INFO)
logger = logging.getLogger(__name__)

ENTITY_TYPES = (
  "animals",
  "building",
  "buildings",
  #"intro",
  "items",
  "misc",
  "particles",
  "projectiles",
  "props",
  #"trailer",
  "vegetation",
  #"verlet_chains",
)

def walk_files(path):
  "Recursively enumerate all files in the given path"
  for root, dirnames, filenames in os.walk(path):
    for filename in filenames:
      yield os.path.join(root, filename)

def scan_for_entities(data):
  "Enumerate all of the entities files in the data.wak directory"
  entity_dir = os.path.join(data, "entities")
  for etype in ENTITY_TYPES:
    tree = os.path.join(entity_dir, etype)
    for path in walk_files(tree):
      name = os.path.basename(path)
      base, ext = os.path.splitext(name)
      if ext == ".xml":
        yield etype, path

def parse_xml(path):
  "Parse the path as XML; returns None on XML parse failure"
  with open(path, "rt") as fobj:
    text = fobj.read().expandtabs()

  while "<!--" in text: # remove comments
    start_pos = text.index("<!--")
    end_pos = text.index("-->", start_pos) + 3
    text = text[:start_pos] + text[end_pos:]

  try:
    root = et.parse(io.StringIO(text)).getroot()
  except et.ParseError as err:
    logger.error("Failed to parse %s: %s", path, err)
    return None
  return root

def escape(value):
  "Escape a string for embedding into Lua"
  result = ""
  for char in value:
    code = ord(char)
    if char != repr(char)[1:-1]:
      result = result + f"\\x{code:02x}"
    elif char == '"':
      result = result + '\\"'
    else:
      result = result + char
  return '"' + result + '"'

def has_tag(root, tag):
  "True if the XML document root has the given tag"
  tags = root.attrib.get("tags", "").split(",")
  return tag in tags

def process_file(tree, path):
  "Determine everything we need to know about the entity file"
  root = parse_xml(path)
  if root is None:
    return None # error feedback handled in parse_xml
  filename = os.path.basename(path)
  prefix = os.path.splitext(filename)[0]
  result = {
    "path": path[path.index("entities/" + tree):],
    "abspath": path,
    "file": filename,
    "prefix": prefix,
    "name": "",
    "tags": "",
    "tree": tree,
  }
  if root.attrib.get("name"):
    result["name"] = root.attrib["name"]
  if root.attrib.get("tags"):
    result["tags"] = root.attrib["tags"]

  return result

def generate_file(entities, output_path):
  "Generate the lua file"
  with open(output_path, "wt") as fobj:
    fobj.write(f"--[[ This file was generated by {__file__}; do not modify! ]]\n")
    fobj.write("\nreturn {\n")
    for tree in entities:
      fobj.write(f"{tree} = {{\n")
      for entry in entities[tree]:
        emit_entity(fobj, entry, asep="\n", indent=4)
      fobj.write(f"}}, -- end of {tree}\n")
    fobj.write("}\n")

def emit_entity(fobj, entity, asep="\n", indent=4):
  "Emit a single entity"
  i = " "*indent
  fobj.write(f"{i}[{escape(entity['prefix'])}] = {{{asep}")
  fobj.write(f"{i*2}file = {escape(entity['file'])},{asep}")
  fobj.write(f"{i*2}name = {escape(entity['name'])},{asep}")
  fobj.write(f"{i*2}path = {escape(entity['path'])},{asep}")
  fobj.write(f"{i*2}tags = {escape(entity['tags'])},{asep}")
  fobj.write(f"{i}}},\n")

def main():
  ap = argparse.ArgumentParser()
  ap.add_argument("data", help="path to extracted data.wak directory")
  ap.add_argument("-o", "--output", metavar="FILE", help="output file path")
  ap.add_argument("-v", "--verbose", action="store_true", help="verbose output")
  args = ap.parse_args()
  if args.verbose:
    logger.setLevel(logging.DEBUG)

  type_counts = collections.defaultdict(int)
  count = 0
  entities = collections.defaultdict(list)
  failures = []
  for kind, file in scan_for_entities(args.data):
    count += 1
    data = process_file(kind, file)
    if data is None:
      failures.append(file)
      continue

    type_counts[kind] += 1
    entities[kind].append(data)

  logger.debug("Processed %d files (%d failures)", count, len(failures))
  logger.debug("Counts: %s", dict(type_counts))

  output = args.output
  if output is None:
    output = os.path.join(os.path.dirname(__file__), "entities.lua")
  logger.debug("Generating %s", output)
  generate_file(entities, output)

if __name__ == "__main__":
  main()

# vim: set ts=2 sts=2 sw=2:
